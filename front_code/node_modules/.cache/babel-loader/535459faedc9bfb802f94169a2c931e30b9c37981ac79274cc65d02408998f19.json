{"ast":null,"code":"// import * as THREE from 'three';\n// import { STLLoader } from 'three/examples/jsm/loaders/STLLoader';\nimport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\nimport { MTLLoader } from 'three/addons/loaders/MTLLoader.js';\nimport { OBJLoader } from 'three/addons/loaders/OBJLoader.js';\nexport const allBaseObject = [];\nfunction getModelLoader(fileType) {\n  switch (fileType) {\n    // case 'stl':\n    //   return new STLLoader();\n    case 'mtl':\n      return new MTLLoader();\n    case 'gltf':\n    case 'glb':\n      return new GLTFLoader();\n    case 'obj':\n      return new OBJLoader();\n    // 或者返回一个包含 .obj 和 .mtl 加载逻辑的对象\n    default:\n      throw new Error('Unsupported file type');\n  }\n}\nasync function loadModel(url, baseURL, modelName) {\n  const fileExtension = url.split('.').pop().toLowerCase();\n  let loader;\n  switch (fileExtension) {\n    case 'obj':\n      loader = getModelLoader('mtl'); // First load MTL for OBJ\n      break;\n    case 'gltf':\n    case 'glb':\n      loader = getModelLoader(fileExtension);\n      break;\n    case 'stl':\n      loader = getModelLoader(fileExtension);\n      break;\n    default:\n      throw new Error(`Unsupported file extension: ${fileExtension}`);\n  }\n  if (fileExtension === 'obj') {\n    const mtlUrl = `${baseURL}${modelName}.mtl`;\n    const objUrl = `${baseURL}${modelName}.obj`;\n    const materials = await new Promise((resolve, reject) => {\n      const mtlLoader = new MTLLoader();\n      mtlLoader.setPath(baseURL);\n      mtlLoader.load(mtlUrl, resolve, undefined, reject);\n    });\n    const objLoader = new OBJLoader();\n    objLoader.setMaterials(materials);\n    const geometryOrScene = await new Promise((resolve, reject) => {\n      objLoader.load(objUrl, resolve, undefined, reject);\n    });\n    return {\n      geometryOrScene,\n      meshName: 'objObject'\n    };\n  } else if (['gltf', 'glb'].includes(fileExtension)) {\n    const gltfLoader = new GLTFLoader();\n    gltfLoader.setPath(baseURL);\n    const gltf = await new Promise((resolve, reject) => {\n      gltfLoader.load(`${modelName}.${fileExtension}`, resolve, undefined, reject);\n    });\n    return {\n      geometryOrScene: gltf.scene,\n      meshName: 'gltfObject'\n    };\n  } else if (fileExtension === 'stl') {\n    const stlLoader = new STLLoader();\n    stlLoader.setPath(baseURL);\n    const geometry = await new Promise((resolve, reject) => {\n      stlLoader.load(`${modelName}.${fileExtension}`, resolve, undefined, reject);\n    });\n    const material = new THREE.MeshStandardMaterial({\n      color: 0x808080\n    });\n    const mesh = new THREE.Mesh(geometry, material);\n    return {\n      geometryOrScene: mesh,\n      meshName: 'stlMesh'\n    };\n  }\n}\n\n// 示例调用\n(async () => {\n  try {\n    const {\n      geometryOrScene,\n      meshName\n    } = await loadModel('/public/static/wu.obj', '/public/static/', 'wu');\n    if (geometryOrScene && meshName) {\n      geometryOrScene.name = meshName;\n      scene.add(geometryOrScene);\n    } else {\n      console.warn('Loaded model or mesh name is undefined.');\n    }\n  } catch (error) {\n    console.error('Failed to load model:', error);\n  }\n})();","map":{"version":3,"names":["GLTFLoader","MTLLoader","OBJLoader","allBaseObject","getModelLoader","fileType","Error","loadModel","url","baseURL","modelName","fileExtension","split","pop","toLowerCase","loader","mtlUrl","objUrl","materials","Promise","resolve","reject","mtlLoader","setPath","load","undefined","objLoader","setMaterials","geometryOrScene","meshName","includes","gltfLoader","gltf","scene","stlLoader","STLLoader","geometry","material","THREE","MeshStandardMaterial","color","mesh","Mesh","name","add","console","warn","error"],"sources":["D:/A.yichuang/Codespaces/front_code/src/components/modelShow/TBaseObject.js"],"sourcesContent":["// import * as THREE from 'three';\r\n// import { STLLoader } from 'three/examples/jsm/loaders/STLLoader';\r\nimport { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\r\nimport { MTLLoader } from 'three/addons/loaders/MTLLoader.js';\r\nimport { OBJLoader } from 'three/addons/loaders/OBJLoader.js';\r\n\r\nexport const allBaseObject = [];\r\n\r\nfunction getModelLoader(fileType) {\r\n  switch (fileType) {\r\n    // case 'stl':\r\n    //   return new STLLoader();\r\n    case 'mtl':\r\n      return new MTLLoader();\r\n    case 'gltf':\r\n    case 'glb':\r\n      return new GLTFLoader();\r\n    case 'obj':\r\n      return new OBJLoader(); // 或者返回一个包含 .obj 和 .mtl 加载逻辑的对象\r\n    default:\r\n      throw new Error('Unsupported file type');\r\n  }\r\n}\r\n\r\nasync function loadModel(url, baseURL, modelName) {\r\n  const fileExtension = url.split('.').pop().toLowerCase();\r\n\r\n  let loader;\r\n  switch (fileExtension) {\r\n    case 'obj':\r\n      loader = getModelLoader('mtl'); // First load MTL for OBJ\r\n      break;\r\n    case 'gltf':\r\n    case 'glb':\r\n      loader = getModelLoader(fileExtension);\r\n      break;\r\n    case 'stl':\r\n      loader = getModelLoader(fileExtension);\r\n      break;\r\n    default:\r\n      throw new Error(`Unsupported file extension: ${fileExtension}`);\r\n  }\r\n\r\n  if (fileExtension === 'obj') {\r\n    const mtlUrl = `${baseURL}${modelName}.mtl`;\r\n    const objUrl = `${baseURL}${modelName}.obj`;\r\n\r\n    const materials = await new Promise((resolve, reject) => {\r\n      const mtlLoader = new MTLLoader();\r\n      mtlLoader.setPath(baseURL);\r\n      mtlLoader.load(mtlUrl, resolve, undefined, reject);\r\n    });\r\n\r\n    const objLoader = new OBJLoader();\r\n    objLoader.setMaterials(materials);\r\n    \r\n    const geometryOrScene = await new Promise((resolve, reject) => {\r\n      objLoader.load(objUrl, resolve, undefined, reject);\r\n    });\r\n\r\n    return { geometryOrScene, meshName: 'objObject' };\r\n  } else if (['gltf', 'glb'].includes(fileExtension)) {\r\n    const gltfLoader = new GLTFLoader();\r\n    gltfLoader.setPath(baseURL);\r\n\r\n    const gltf = await new Promise((resolve, reject) => {\r\n      gltfLoader.load(`${modelName}.${fileExtension}`, resolve, undefined, reject);\r\n    });\r\n\r\n    return { geometryOrScene: gltf.scene, meshName: 'gltfObject' };\r\n  } else if (fileExtension === 'stl') {\r\n    const stlLoader = new STLLoader();\r\n    stlLoader.setPath(baseURL);\r\n\r\n    const geometry = await new Promise((resolve, reject) => {\r\n      stlLoader.load(`${modelName}.${fileExtension}`, resolve, undefined, reject);\r\n    });\r\n\r\n    const material = new THREE.MeshStandardMaterial({ color: 0x808080 });\r\n    const mesh = new THREE.Mesh(geometry, material);\r\n    return { geometryOrScene: mesh, meshName: 'stlMesh' };\r\n  }\r\n}\r\n\r\n// 示例调用\r\n(async () => {\r\n  try {\r\n    const { geometryOrScene, meshName } = await loadModel('/public/static/wu.obj', '/public/static/', 'wu');\r\n\r\n    if (geometryOrScene && meshName) {\r\n      geometryOrScene.name = meshName;\r\n      scene.add(geometryOrScene);\r\n    } else {\r\n      console.warn('Loaded model or mesh name is undefined.');\r\n    }\r\n  } catch (error) {\r\n    console.error('Failed to load model:', error);\r\n  }\r\n})();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}